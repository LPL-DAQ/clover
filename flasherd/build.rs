use dirs::data_dir;
use std::fs::{File, read_to_string};
use std::io::Write;
use std::path::{Path, PathBuf};
use std::{env, fs, io};
use sysinfo::{Pid, System};
use which::which;

fn main() -> Result<(), Box<dyn std::error::Error>> {
    let compiled_path = PathBuf::from(env::var("OUT_DIR")?).join("flasherd.rs");
    let compiled_copy_path = Path::new("flasherd-proto-compiled.rs");
    match which("protoc") {
        // In dev container, protoc should compile
        Ok(_) => {
            tonic_prost_build::compile_protos("../api/flasherd.proto")?;
            let mut compiled = File::open(compiled_path)?;
            let mut compiled_copy = File::create(compiled_copy_path)?;
            compiled_copy.write_all(b"// This file is automatically generated by dev container-internal builds of flasherd for use in host compilation of flasherd without protoc.\n")?;
            io::copy(&mut compiled, &mut compiled_copy)?;
        }

        // On host machine, fallback to precompiled proto
        Err(_) => {
            fs::copy(compiled_copy_path, compiled_path)?;
        }
    }

    // Ensure flasherd is closed
    // Kill old process, if it exists
    let pid_path = data_dir().unwrap().join("flasherd.pid");
    println!("cargo:rerun-if-changed={}", pid_path.display());
    match read_to_string(&pid_path) {
        Err(err) => {
            if !matches!(err.kind(), std::io::ErrorKind::NotFound) {
                panic!("Failed to read pid path {pid_path:?}: {err:?}");
            }
        }
        Ok(pid) => {
            let sys = System::new_all();
            if let Some(process) = sys.process(Pid::from(pid.parse::<usize>().unwrap()))
                && let Some(bin_path) = process.exe()
                && let Some(bin_name) = bin_path.file_name()
                && bin_name == "flasherd"
            {
                _ = process.kill_and_wait().unwrap();
            };
        }
    }
    Ok(())
}
